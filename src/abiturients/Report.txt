	Отчет на тему: "Как влияет на перегрузку и переопределение методов изменение сигнатуры метода, типа возвращаемого значения и модификатора доступа".

		Рассмотрение данного вопроса следует начинать с рассмотрения основных понятий: 
	- Сигнатура метода
	- Тип возвращаемого значения
	- Модификатор доступа
	- Перегрузка и переопределние методов
	
		Сигнатура метода:
	
		Сигнатурой метода называется совокупность его имени и набора формальных параметров.
	Java позволяет создавать несколько методов с одинаковыми именами, но разными сигнатурами. Компилятор различает методы не по их именам, а по сигнатурам. 
	Тип возвращаемого значения не входит в сигнатуру метода, значит, методы не могут различаться только типом результата их работы.

		Пример сигнатуры метода:

	modifier returnType nameOfMethod (Parameter List) {
	// тело метода
	}
	
		Синтаксис показанный выше включает в себя:
	- modifier: Он определяет тип доступа метода и не является обязательным для использования.
	- returnType: Метод может возвращать значение. 
	- nameOfMethod: Это имя метода. Сигнатура метода состоит из имени метода и списка параметров.
	- Parameter List: Список параметров, это тип, порядок и количество параметров метода. Они не являются обязательными, способ может содержать нулевые параметры
	- method body: Тело метод определяет то , что делает метод.

		Тип возвращаемого значения:

		Методы в Java условно можно разделить на 2 группы: функции и процедуры. К первой группе относятся методы, очень похожие на функции в математическом смысле.
	В результате своей работы такие методы возвращают в то место программы, из которого они были вызваны, некоторый конкретный результат существующего типа, то есть
	это может быть целое или вещественное число или логическое значение (int, double, boolean), массив (ссылка на него), объект (ссылка на него). Возвращаемое
	значение должно присваиваться переменной подходящего типа или же передаваться какому-либо другому методу в роли аргумента.

		В отличие от функций, методы процедурного типа производят какие-либо полезные действия, но не дают законченного результата, который мог бы выражаться в 
		одном конкретном значении или объекте.
		
	Пример типа возвращаемого значения:

	double r = Math.random();
	/* random  относится к функциям */
	System.out.println(r);
	/* println относится к процедурам */
	
		При создании метода в первую очередь надо определить, будет ли он функцией или процедурой. Для промежуточных вычислений, как правило, используются функции.
	Для сокращения однотипных фрагментов кода могут подходить и процедуры.
		После модификаторов, но также слева от имени метода, указывается тип возвращаемого им значения (если метод является функцией, например: int[] или double) 
	или же слово void (если метод является процедурой).
		Если метод является функцией, то в нём обязательно должна встречаться команда return после которой через пробел указывается то выражение, значение которого
	должно быть возвращено в качестве результата работы метода.
		Все команды, указанные в описании метода после return, выполняться уже не будут, return без аргумента можно использовать внутри процедур. Он будет просто
		досрочно завершать процедуру (аналог break для цикла).

		Модификатор доступа метода:
	
		Модификатор - это ключевое слово языка, которое может каким-либо образом изменить смысл некоторого определения (например, класса или метода).	
		Public. Это модификатор доступа. Модификаторы доступа регулируют видимость методов (а также переменных и классов) из других классов. public означает,
	что переменная, метод или класс (перед чем стоит public) виден всем. protected видят потомки класса, а private не видит никто за границами класса. Для чего
	нужны модификаторы доступа? Для правильной инкапсуляции. Все вспомогательные переменные и методы в классе должны объявляться как private. Это повышает
	живучесть программы, заставляет общаться с классом при помощи его методов и вообще, это хороший тон. Если при объявлении члена класса не указан ни один 
	из перечисленных модификаторов, используется модификатор по умолчанию (default). Он означает, что доступ к члену класса имеют все классы, объявленные в 
	том же пакете. В реализации класса мы встречаем еще два	зарезервированных слова-компилятора. Это static и final. final говорит о том, что класс является
	конечным, т.е. не допускающим образования от него потомков, а static определяет количество экземпляров. Если перед переменной или методом стоит static,
	то этот метод (или эта переменная) будет существовать в единственном экземпляре для всех экземпляров класса которому они принадлежат.
	
	Перепишем класс Dog следующим образом:
	
	class	Dog {
		private int age;// возраст
		private	String name; // кличка
		public	Dog(String n, int a) {
		name = n; age = a;
		}
		public void	voice() {
			for(int i = 1; i <= age; i++) {
		System.out.println("гав-гав");
			}
		}
	}
	
		Поля age и name окажутся скрытыми. Это значит, что мы не можем изменять их (или считывать их значение) где-либо за пределами класса*. Мы не сможем в методе main() создать объект класса Dog, а затем присвоить его полю age или name новое значение, как в следующем примере:
		
		public static void main(String[] args) {
		Dog dog1 = new Dog("Тузик", 4);
		dog1.age = 10; // нельзя, поле age скрыто
		dog1.name = "Жучка"; // переименовать собаку тоже нельзя, поле name скрыто
		dog1.voice(); // это можно, метод voice() открытый
		}
		
		Возможность скрывать поля и методы класса используется для того, чтобы уберечь программиста от возможных ошибок, сделать классы понятнее и проще в использовании. При этом реализуется принцип инкапсуляции.
	об инкапсуляции
	Инкапсуляция означает сокрытие деталей реализации класса. Класс разделяется на две части: внутреннюю и внешнюю. Внешняя часть (интерфейс) тщательно продумывается исходя из того, каким образом могут взаимодействовать с объектами данного класса другие объекты программы. Внутренняя часть закрыта от посторонних, она нужна только самому классу для обеспечения правильной работы открытых методов.
	Последовательность модификаторов по убыванию уровня закрытости: private, default ,protected, public).

		Перегрузка и переопределение методов (override и overload)

		Создание метода с тем же именем, но с другим набором параметров называется перегрузкой. Какой из перегруженных методов должен выполняться при вызове, Java определяет на основе фактических параметров.
	   
	void pr( double a) {
	System.out.println(a);
	}
	void pr (String a) {
	System.out.println(a);
	}
	void pr(int[] a) {
		for (int i=0; i<a.length; i++) {
	System.out.print(a[i]+" ")
	}
	System.out.println();
	}
	   
		Пример использования метода:
	
	int a = 5;
	int [] m = {1, 2, 8, 3}
	String s = "Мир";
	pr (a) //работает исходный метод
	pr (a+s); // 5 мир, работает первая перегрузка
	pr (m); // 1 2 8 3
	pr (m+a); // ошибка
	   
		Переменная а не относится к типу double, но её обрабатывает исходный метод, поскольку возможно автоприведение из int в double. В обратном направлении оно невозможно. Если бы метод имел аргумент типа int, то с его помощью вещественные числа выводить не получилось бы.
	Перегрузка методов реализует такое важное свойство в программировании, как полиморфизм. Полиморфным называется программный код, который связан с одним общим именем, но имеет разные реализации. Какая из реализаций будет работать, выбирается на основе контекста, в котором имя было упомянуто. Конкретно для методов полиморфными являются их перегрузки, а выбор исполняемой перегрузки происходит по параметрам.
	Переопределение используется тогда, когда вы переписываете (переделываете, переопределяете) УЖЕ существующий метод. Например в классе Object есть очень популярный метод toString(), который возвращает строковое представление объекта. Давайте запустим очень простой пример:

	1. public class Robot
	2. {
	3. }
	1. public class RobotManager
	2. {
	3. public static void main(String[] args) {
	4. Robot robot = new Robot();
	5. System.out.println(robot.toString());
	6. }
	7. }
	   
	   Наш класс Robot сейчас совсем ничего не имеет и наследуется от класса Object, который, как мы уже говорили, имеет метод toString. Во втором классе RobotManager мы вызвали этот метод и вывели на экран результаты его выполнения.
	Robot@119298d
	Переопределим этот метод и немного усложним наш класс Robot. Введем дополнительное поле с именем робота и будем возвращать из метода toString это значение. Сразу определим конструктор, который будет принимать имя при создании объекта.
	   
	1. public class Robot
	2. {
	3. private String name;
	4. public Robot(String name) {
	5. this.name = name;
	6. }
	7. @Override
	8. public String toString() {
	9. return "name=" + name;
	10. }
	11. }
	1. public class RobotManager
	2. {
	3. public static void main(String[] args) {
	4. Robot robot1 = new Robot("Test Robot 1");
	5. Robot robot2 = new Robot("Test Robot 2");
	6. System.out.println(robot1.toString());
	7. System.out.println(robot2.toString());
	8. }
	9. }
	   @Override. Называется эта конструкция «аннотация». Служит для включения дополнительной информации, которую можно прочитать и использовать. Компилятор получает возможность проверить, что вы переопределили метод, а не написали новый. Таким образом можно избежать некоторых ошибок из-за невнимательности. 
	Заголовок метода toString должен в точности совпадать с таким же методом у класса-предка — название, возвращаемое значение и список параметров. В данном случае у нас нет параметров и возвращаемое значение является строкой. Теперь мы получили класс, который ПЕРЕОПРЕДЕЛИЛ уже существующий метод предка. Таким образом можно изменять функциональность класса, его поведение. Мы не использовали исходный код класса Object — его у нас нет. Но тем не менее мы смогли поменять его поведение. Это является большим удобством при разработке программ. В обычной жизни программист на Java постоянно что-то наследует, переопределяет.
	   
	Вывод:
	   
	  Методы могут быть перегружены и переопределены. Конструкторы — только перегружены.
	При переопределении методы
	Должны иметь неизменный список агрументов.
	Должны иметь неизменный тип возвращаемого значения.
	Уровень доступа не может быть ниже наследованного метода.
	Не должны бросать новых exception'ов.
	Переопределяться могут только наследованные методы.
	Получить доступ к переопределяемому методу можно так:
		public  class Fruit {
			public void eat(){
				System.out.println("NomNomNom");
			}
		}
	class Apple extends Fruit{
		public void grow(){
			System.out.println("I'm growing");
		}
		public void eat(){
			System.out.println("NomAppleNom");
		}
		public void test(){
			eat();//Вызовет переопределенный метод
			super.eat();//Вызовет метод суперкласса
		}
	}
		
		При перегрузке методы:
	- Должны иметь новый список аргументов.
	- Могут иметь новый тип возвращаемого значения.
	- Могут иметь новый уровень доступа без ограничений.
	- Могут бросать новые exception'ы
	- Методы суперкласса могут быть перегружены в наследнике.
	- Полиморфизм применим только к переопределению — не к перезагрузке.


		Типы возвращаемых значений:

		Можно использовать null и массивы в качестве возвращаемого значения.
	Если тип возвращаемого значения примитивный (byte, int, float etc), то java выполнит неявное приведение типов, если это возможно.
	public  class Fruit {
		public int eat(){
			byte b = 127; 
			return b; //Компилятор автоматически расширит byte b до int.
		}
		public int grow(){
			long l = 42;
			return l;  //Ошибка! Несмотря на то что int вполне может представить число 42 без потерь,
							//нам необходимо использовать явное приведение return (int) l;
		}
	}

	Для void-методов можно использовать ключевое слово return, если вы хотите прервать метод.
	Если метод возвращает объект, в качестве возвращаемого значения можно использовать наследников класса этого объекта.